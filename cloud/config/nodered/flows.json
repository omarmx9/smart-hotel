[
    {
        "id": "notification-flow-tab",
        "type": "tab",
        "label": "Notification Gateway",
        "disabled": false,
        "info": "Smart Hotel notification gateway with Telegram, SMS (Twilio), and MQTT integration"
    },
    {
        "id": "mqtt-broker-config",
        "type": "mqtt-broker",
        "name": "Mosquitto",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "nodered-notifications",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "hotel/nodered/status",
        "birthQos": "1",
        "birthPayload": "online",
        "birthMsg": {},
        "closeTopic": "hotel/nodered/status",
        "closeQos": "1",
        "closePayload": "offline",
        "closeMsg": {},
        "willTopic": "hotel/nodered/status",
        "willQos": "1",
        "willPayload": "offline",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "mqtt-notify-input",
        "type": "mqtt in",
        "z": "notification-flow-tab",
        "name": "hotel/notifications/send",
        "topic": "hotel/notifications/send",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 100,
        "wires": [["process-notification"]]
    },
    {
        "id": "process-notification",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Process Notification",
        "func": "// Expected payload:\n// {\n//   type: 'guest_credentials' | 'alert' | 'system',\n//   recipient: { phone: '+1234567890', chat_id: '123456' },\n//   message: 'Your message here',\n//   priority: 'high' | 'normal',\n//   metadata: { room: '101', guest: 'john' }\n// }\n\nconst notification = msg.payload;\n\nif (!notification || !notification.message) {\n    node.warn('Invalid notification: missing message');\n    return null;\n}\n\n// Store original notification for logging\nmsg.originalNotification = notification;\nmsg.notificationId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);\nmsg.attempts = [];\n\n// Check what services are configured\nconst telegramToken = global.get('TELEGRAM_BOT_TOKEN');\nconst telegramChatId = notification.recipient?.chat_id || global.get('TELEGRAM_CHAT_ID');\nconst twilioSid = global.get('TWILIO_ACCOUNT_SID');\nconst twilioToken = global.get('TWILIO_AUTH_TOKEN');\nconst twilioPhone = global.get('TWILIO_PHONE_NUMBER');\n\nmsg.telegramConfigured = !!(telegramToken && telegramChatId);\nmsg.smsConfigured = !!(twilioSid && twilioToken && twilioPhone && notification.recipient?.phone);\n\nmsg.telegramConfig = {\n    token: telegramToken,\n    chatId: telegramChatId\n};\n\nmsg.smsConfig = {\n    accountSid: twilioSid,\n    authToken: twilioToken,\n    fromNumber: twilioPhone,\n    toNumber: notification.recipient?.phone\n};\n\nmsg.messageText = notification.message;\nmsg.notificationType = notification.type || 'system';\nmsg.priority = notification.priority || 'normal';\n\n// If neither is configured, go straight to admin notification\nif (!msg.telegramConfigured && !msg.smsConfigured) {\n    msg.failureReason = 'No notification services configured';\n    return [null, null, msg];\n}\n\n// Try Telegram first if configured\nif (msg.telegramConfigured) {\n    return [msg, null, null];\n}\n\n// Otherwise try SMS\nif (msg.smsConfigured) {\n    return [null, msg, null];\n}\n\nreturn null;",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 100,
        "wires": [["send-telegram"], ["send-sms"], ["notify-admin-failure"]]
    },
    {
        "id": "send-telegram",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Send Telegram",
        "func": "const https = require('https');\n\nconst { token, chatId } = msg.telegramConfig;\nconst message = msg.messageText;\n\nconst postData = JSON.stringify({\n    chat_id: chatId,\n    text: message,\n    parse_mode: 'HTML'\n});\n\nconst options = {\n    hostname: 'api.telegram.org',\n    port: 443,\n    path: '/bot' + token + '/sendMessage',\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(postData)\n    }\n};\n\nreturn new Promise((resolve) => {\n    const req = https.request(options, (res) => {\n        let data = '';\n        res.on('data', chunk => data += chunk);\n        res.on('end', () => {\n            try {\n                const response = JSON.parse(data);\n                if (response.ok) {\n                    msg.attempts.push({ service: 'telegram', success: true, messageId: response.result.message_id });\n                    msg.deliverySuccess = true;\n                    msg.deliveryMethod = 'telegram';\n                    resolve([msg, null]);\n                } else {\n                    msg.attempts.push({ service: 'telegram', success: false, error: response.description });\n                    if (msg.smsConfigured) {\n                        resolve([null, msg]);\n                    } else {\n                        msg.failureReason = 'Telegram failed, SMS not configured';\n                        resolve([null, msg]);\n                    }\n                }\n            } catch (e) {\n                msg.attempts.push({ service: 'telegram', success: false, error: 'Parse error' });\n                if (msg.smsConfigured) {\n                    resolve([null, msg]);\n                } else {\n                    msg.failureReason = 'Telegram failed, SMS not configured';\n                    resolve([null, msg]);\n                }\n            }\n        });\n    });\n    \n    req.on('error', (e) => {\n        msg.attempts.push({ service: 'telegram', success: false, error: e.message });\n        if (msg.smsConfigured) {\n            resolve([null, msg]);\n        } else {\n            msg.failureReason = 'Telegram connection failed, SMS not configured';\n            resolve([null, msg]);\n        }\n    });\n    \n    req.setTimeout(10000, () => {\n        req.destroy();\n        msg.attempts.push({ service: 'telegram', success: false, error: 'Timeout' });\n        if (msg.smsConfigured) {\n            resolve([null, msg]);\n        } else {\n            msg.failureReason = 'Telegram timeout, SMS not configured';\n            resolve([null, msg]);\n        }\n    });\n    \n    req.write(postData);\n    req.end();\n});",
        "outputs": 2,
        "timeout": "15",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 60,
        "wires": [["log-success"], ["send-sms-fallback"]]
    },
    {
        "id": "send-sms-fallback",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "SMS Fallback Check",
        "func": "if (msg.smsConfigured) {\n    return [msg, null];\n} else {\n    msg.failureReason = msg.failureReason || 'All notification methods failed';\n    return [null, msg];\n}",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 120,
        "wires": [["send-sms"], ["notify-admin-failure"]]
    },
    {
        "id": "send-sms",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Send SMS (Twilio)",
        "func": "const https = require('https');\n\nconst { accountSid, authToken, fromNumber, toNumber } = msg.smsConfig;\nconst message = msg.messageText;\n\nif (!toNumber) {\n    msg.attempts.push({ service: 'sms', success: false, error: 'No phone number provided' });\n    msg.failureReason = 'SMS failed: no phone number';\n    return [null, msg];\n}\n\nconst postData = new URLSearchParams({\n    To: toNumber,\n    From: fromNumber,\n    Body: message\n}).toString();\n\nconst options = {\n    hostname: 'api.twilio.com',\n    port: 443,\n    path: '/2010-04-01/Accounts/' + accountSid + '/Messages.json',\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData),\n        'Authorization': 'Basic ' + Buffer.from(accountSid + ':' + authToken).toString('base64')\n    }\n};\n\nreturn new Promise((resolve) => {\n    const req = https.request(options, (res) => {\n        let data = '';\n        res.on('data', chunk => data += chunk);\n        res.on('end', () => {\n            try {\n                const response = JSON.parse(data);\n                if (res.statusCode >= 200 && res.statusCode < 300) {\n                    msg.attempts.push({ service: 'sms', success: true, sid: response.sid });\n                    msg.deliverySuccess = true;\n                    msg.deliveryMethod = 'sms';\n                    resolve([msg, null]);\n                } else {\n                    msg.attempts.push({ service: 'sms', success: false, error: response.message, code: response.code });\n                    msg.failureReason = 'SMS delivery failed: ' + response.message;\n                    resolve([null, msg]);\n                }\n            } catch (e) {\n                msg.attempts.push({ service: 'sms', success: false, error: 'Parse error' });\n                msg.failureReason = 'SMS failed: parse error';\n                resolve([null, msg]);\n            }\n        });\n    });\n    \n    req.on('error', (e) => {\n        msg.attempts.push({ service: 'sms', success: false, error: e.message });\n        msg.failureReason = 'SMS connection failed: ' + e.message;\n        resolve([null, msg]);\n    });\n    \n    req.setTimeout(15000, () => {\n        req.destroy();\n        msg.attempts.push({ service: 'sms', success: false, error: 'Timeout' });\n        msg.failureReason = 'SMS timeout';\n        resolve([null, msg]);\n    });\n    \n    req.write(postData);\n    req.end();\n});",
        "outputs": 2,
        "timeout": "20",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 100,
        "wires": [["log-success"], ["notify-admin-failure"]]
    },
    {
        "id": "log-success",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Log Success",
        "func": "const stats = flow.get('notification_stats') || { sent: 0, failed: 0, telegram: 0, sms: 0 };\nstats.sent++;\nif (msg.deliveryMethod === 'telegram') stats.telegram++;\nif (msg.deliveryMethod === 'sms') stats.sms++;\nflow.set('notification_stats', stats);\n\nconst result = {\n    id: msg.notificationId,\n    type: msg.notificationType,\n    success: true,\n    method: msg.deliveryMethod,\n    attempts: msg.attempts,\n    timestamp: new Date().toISOString()\n};\n\nmsg.topic = 'hotel/notifications/result';\nmsg.payload = result;\n\nnode.status({ fill: 'green', shape: 'dot', text: 'Sent via ' + msg.deliveryMethod });\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 60,
        "wires": [["mqtt-result-output"]]
    },
    {
        "id": "notify-admin-failure",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Notify Admin of Failure",
        "func": "const stats = flow.get('notification_stats') || { sent: 0, failed: 0, telegram: 0, sms: 0 };\nstats.failed++;\nflow.set('notification_stats', stats);\n\nconst failure = {\n    id: msg.notificationId,\n    type: 'notification_failure',\n    originalType: msg.notificationType,\n    originalMessage: msg.messageText ? msg.messageText.substring(0, 100) + (msg.messageText.length > 100 ? '...' : '') : '',\n    reason: msg.failureReason,\n    attempts: msg.attempts,\n    timestamp: new Date().toISOString(),\n    priority: 'high'\n};\n\nmsg.topic = 'hotel/notifications/failure';\nmsg.payload = failure;\n\nnode.status({ fill: 'red', shape: 'ring', text: 'Delivery failed' });\nnode.warn('Notification delivery failed: ' + msg.failureReason);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 160,
        "wires": [["mqtt-failure-output"]]
    },
    {
        "id": "mqtt-result-output",
        "type": "mqtt out",
        "z": "notification-flow-tab",
        "name": "Publish Result",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 1180,
        "y": 60,
        "wires": []
    },
    {
        "id": "mqtt-failure-output",
        "type": "mqtt out",
        "z": "notification-flow-tab",
        "name": "Publish Failure",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 1190,
        "y": 160,
        "wires": []
    },
    {
        "id": "http-send-notification",
        "type": "http in",
        "z": "notification-flow-tab",
        "name": "POST /notify",
        "url": "/notify",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 220,
        "wires": [["http-validate-notify"]]
    },
    {
        "id": "http-validate-notify",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Validate & Bridge",
        "func": "const { message, recipient, type, priority } = msg.payload;\n\nif (!message) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Missing required field: message' };\n    return [null, msg];\n}\n\nmsg.payload = {\n    type: type || 'system',\n    recipient: recipient || {},\n    message: message,\n    priority: priority || 'normal'\n};\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 220,
        "wires": [["process-notification", "http-accepted"], ["http-error-response"]]
    },
    {
        "id": "http-accepted",
        "type": "http response",
        "z": "notification-flow-tab",
        "name": "202 Accepted",
        "statusCode": "202",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 540,
        "y": 260,
        "wires": []
    },
    {
        "id": "http-error-response",
        "type": "http response",
        "z": "notification-flow-tab",
        "name": "Error Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 540,
        "y": 300,
        "wires": []
    },
    {
        "id": "http-health",
        "type": "http in",
        "z": "notification-flow-tab",
        "name": "GET /health",
        "url": "/health",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 380,
        "wires": [["health-check"]]
    },
    {
        "id": "health-check",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Health Check",
        "func": "const telegramToken = global.get('TELEGRAM_BOT_TOKEN');\nconst telegramChatId = global.get('TELEGRAM_CHAT_ID');\nconst twilioSid = global.get('TWILIO_ACCOUNT_SID');\nconst twilioToken = global.get('TWILIO_AUTH_TOKEN');\nconst twilioPhone = global.get('TWILIO_PHONE_NUMBER');\n\nconst stats = flow.get('notification_stats') || { sent: 0, failed: 0, telegram: 0, sms: 0 };\n\nmsg.payload = {\n    status: 'ok',\n    services: {\n        telegram: !!(telegramToken && telegramChatId) ? 'configured' : 'not_configured',\n        sms: !!(twilioSid && twilioToken && twilioPhone) ? 'configured' : 'not_configured'\n    },\n    statistics: stats,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 380,
        "wires": [["http-health-response"]]
    },
    {
        "id": "http-health-response",
        "type": "http response",
        "z": "notification-flow-tab",
        "name": "Health Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 550,
        "y": 380,
        "wires": []
    },
    {
        "id": "http-status",
        "type": "http in",
        "z": "notification-flow-tab",
        "name": "GET /status",
        "url": "/status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 440,
        "wires": [["get-status"]]
    },
    {
        "id": "get-status",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Get Detailed Status",
        "func": "const stats = flow.get('notification_stats') || {\n    sent: 0,\n    failed: 0,\n    telegram: 0,\n    sms: 0\n};\n\nmsg.payload = {\n    status: 'ok',\n    statistics: stats,\n    uptime: process.uptime(),\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 440,
        "wires": [["http-status-response"]]
    },
    {
        "id": "http-status-response",
        "type": "http response",
        "z": "notification-flow-tab",
        "name": "Status Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 570,
        "y": 440,
        "wires": []
    },
    {
        "id": "mqtt-admin-alerts",
        "type": "mqtt in",
        "z": "notification-flow-tab",
        "name": "hotel/alerts/#",
        "topic": "hotel/alerts/#",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 520,
        "wires": [["process-alert"]]
    },
    {
        "id": "process-alert",
        "type": "function",
        "z": "notification-flow-tab",
        "name": "Process System Alert",
        "func": "const alert = msg.payload;\nconst topic = msg.topic;\n\nconst alertType = topic.split('/').pop();\n\nlet message = '';\nlet priority = 'normal';\n\nswitch (alertType) {\n    case 'gas':\n        message = '‚ö†Ô∏è GAS ALERT\\nRoom: ' + (alert.room || 'Unknown') + '\\nLevel: ' + alert.level + '\\nTime: ' + new Date().toLocaleString();\n        priority = 'high';\n        break;\n    case 'temperature':\n        message = 'üå°Ô∏è TEMPERATURE ALERT\\nRoom: ' + (alert.room || 'Unknown') + '\\nTemp: ' + alert.temperature + '¬∞C\\nThreshold: ' + alert.threshold + '¬∞C';\n        priority = 'high';\n        break;\n    case 'system':\n        message = 'üîß SYSTEM ALERT\\n' + (alert.message || 'Unknown system event');\n        priority = alert.priority || 'normal';\n        break;\n    default:\n        message = 'üì¢ ALERT: ' + alertType + '\\n' + JSON.stringify(alert);\n}\n\nmsg.payload = {\n    type: 'alert',\n    message: message,\n    priority: priority,\n    recipient: {}\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 520,
        "wires": [["process-notification"]]
    }
]
