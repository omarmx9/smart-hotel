{% extends 'base.html' %}
{% load static %}

{% block title %}Scan Passport - Smart Hotel{% endblock %}

{% block content %}
<div class="scan-page">
    <!-- Camera Section -->
    <div class="card p-4 p-md-5 mb-4" id="cameraSection">
        <div class="scan-header">
            <div class="icon-box icon-brand">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M6 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H6zm6 5a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm-4 9h8a1 1 0 0 1 0 2H8a1 1 0 0 1 0-2z"/>
                </svg>
            </div>
            <div>
                <h1 data-i18n="scan_passport">Scan Your Passport</h1>
                <p data-i18n="scan_passport_instruction">Position your passport within the guide and press Capture when ready.</p>
            </div>
        </div>

        <div class="camera-container" id="cameraContainer">
            <video id="cameraVideo" autoplay playsinline></video>
            <canvas id="captureCanvas" style="display: none;"></canvas>
            <canvas id="overlayCanvas"></canvas>
            
            <div class="camera-overlay">
                <div class="detection-status" id="detectionStatus">
                    <span class="detection-dot" id="detectionDot"></span>
                    <span id="detectionText" data-i18n="searching_document">Searching for document...</span>
                </div>
                
                <!-- Stability Progress Bar -->
                <div class="stability-bar-container" id="stabilityContainer" style="display: none;">
                    <div class="stability-bar" id="stabilityBar"></div>
                    <span class="stability-text" id="stabilityText">Hold steady...</span>
                </div>
                
                <!-- Quality Score -->
                <div class="quality-score" id="qualityScore" style="display: none;">
                    <span class="quality-label">Quality:</span>
                    <span class="quality-value" id="qualityValue">0</span>
                </div>
                
                <!-- FPS Counter (debug) -->
                <div class="fps-counter" id="fpsCounter">-- fps</div>
                
                <div class="passport-guide" id="passportGuide">
                    <span class="passport-guide-text" data-i18n="position_passport">Position passport here</span>
                </div>
                
                <div class="capture-countdown" id="captureCountdown">3</div>
            </div>
            
            <div class="camera-error" id="cameraError" style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="15" y1="9" x2="9" y2="15"/>
                    <line x1="9" y1="9" x2="15" y2="15"/>
                </svg>
                <h3 data-i18n="camera_error">Camera Access Denied</h3>
                <p data-i18n="camera_error_message">Please allow camera access to scan your passport.</p>
                <button class="btn btn-primary mt-3" onclick="initCamera()" data-i18n="retry">Retry</button>
            </div>
            
            <div class="processing-overlay" id="processingOverlay" style="display: none;">
                <div class="spinner"></div>
                <h3 data-i18n="processing_passport">Processing passport...</h3>
                <p data-i18n="please_wait">Please wait</p>
            </div>
        </div>

        <div class="scan-instructions">
            <ul>
                <li data-i18n="instruction_1">Hold your passport flat and steady</li>
                <li data-i18n="instruction_2">Ensure the MRZ (bottom text lines) is visible</li>
                <li data-i18n="instruction_3">Press Capture when the document is aligned</li>
            </ul>
        </div>

        <div class="action-buttons">
            <a href="{% url 'kiosk:checkin' %}" class="btn btn-outline-secondary btn-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 8px;">
                    <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
                </svg>
                <span data-i18n="back">Back</span>
            </a>
            <button type="button" class="btn btn-primary btn-lg" id="captureBtn" onclick="performCapture()">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 8px;">
                    <path d="M10.5 8.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/>
                    <path d="M2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4H2z"/>
                </svg>
                <span data-i18n="capture">Capture</span>
            </button>
            <button type="button" class="btn btn-outline-primary btn-lg" onclick="showManualEntry()">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 8px;">
                    <path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/>
                </svg>
                <span data-i18n="enter_manually">Enter Manually</span>
            </button>
        </div>
    </div>

    <!-- Manual Entry Section -->
    <div class="card p-4 p-md-5 mb-4" id="manualEntrySection" style="display: none;">
        <div class="scan-header">
            <div class="icon-box icon-brand">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z"/>
                </svg>
            </div>
            <div>
                <h1 data-i18n="manual_entry">Enter Guest Information</h1>
                <p data-i18n="manual_entry_instruction">Please enter your passport details manually.</p>
            </div>
        </div>

        <form id="manualEntryForm" method="post" action="{% url 'kiosk:dw_registration_card' %}">
            {% csrf_token %}
            <div class="row g-3 mb-4">
                <div class="col-md-6">
                    <label for="manualFirstName" class="form-label" data-i18n="first_name">First Name</label>
                    <input type="text" class="form-control form-control-lg" id="manualFirstName" name="first_name" required>
                </div>
                <div class="col-md-6">
                    <label for="manualLastName" class="form-label" data-i18n="last_name">Last Name</label>
                    <input type="text" class="form-control form-control-lg" id="manualLastName" name="last_name" required>
                </div>
                <div class="col-md-6">
                    <label for="manualPassportNumber" class="form-label" data-i18n="passport_number">Passport Number</label>
                    <input type="text" class="form-control form-control-lg" id="manualPassportNumber" name="passport_number" required>
                </div>
                <div class="col-md-6">
                    <label for="manualDateOfBirth" class="form-label" data-i18n="date_of_birth">Date of Birth</label>
                    <input type="date" class="form-control form-control-lg" id="manualDateOfBirth" name="date_of_birth" required>
                </div>
                <div class="col-md-6">
                    <label for="manualNationality" class="form-label" data-i18n="nationality">Nationality</label>
                    <input type="text" class="form-control form-control-lg" id="manualNationality" name="nationality" placeholder="e.g., USA, GBR, DEU">
                    <input type="hidden" name="nationality_code" id="manualNationalityCode">
                    <input type="hidden" name="issuer_code" id="manualIssuerCode">
                </div>
            </div>

            <!-- Access method is selected after document signing -->

            <div class="d-flex gap-2 flex-wrap">
                <button type="button" class="btn btn-outline-secondary btn-lg" onclick="hideManualEntry()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 8px;">
                        <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
                    </svg>
                    <span data-i18n="back_to_scan">Back to Scan</span>
                </button>
                <button type="submit" class="btn btn-primary btn-lg">
                    <span data-i18n="continue">Continue</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-left: 8px;">
                        <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
        </form>
    </div>

    <!-- Results Section -->
    <div class="card p-4 p-md-5 results-section" id="resultsSection">
        <div class="result-header">
            <div class="icon-box">
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
                </svg>
            </div>
            <h2 data-i18n="passport_scanned">Passport Scanned Successfully</h2>
        </div>

        <!-- Display Mode -->
        <div id="displayMode">
            <div class="passport-data-grid" id="passportDataGrid">
                <!-- Populated by JavaScript -->
            </div>
            <div class="alert alert-info mt-3" role="alert">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="me-2" viewBox="0 0 16 16">
                    <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                </svg>
                <span data-i18n="review_data_info">Please review the extracted data. You can edit all fields on the next page (Registration Card).</span>
            </div>
        </div>

        <!-- Edit Mode -->
        <div id="editMode" style="display: none;">
            <div class="alert alert-warning mb-3" role="alert">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="me-2" viewBox="0 0 16 16">
                    <path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3z"/>
                    <path d="M13.5 6.207 9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5z"/>
                </svg>
                <span data-i18n="edit_mode_info">Edit the data below and click "Save Changes" when done.</span>
            </div>
            <div class="row g-3 mb-4">
                <div class="col-md-6">
                    <label for="editFirstName" class="form-label" data-i18n="first_name">First Name</label>
                    <input type="text" class="form-control form-control-lg" id="editFirstName">
                </div>
                <div class="col-md-6">
                    <label for="editLastName" class="form-label" data-i18n="last_name">Last Name</label>
                    <input type="text" class="form-control form-control-lg" id="editLastName">
                </div>
                <div class="col-md-6">
                    <label for="editPassportNumber" class="form-label" data-i18n="passport_number">Passport Number</label>
                    <input type="text" class="form-control form-control-lg" id="editPassportNumber">
                </div>
                <div class="col-md-6">
                    <label for="editDateOfBirth" class="form-label" data-i18n="date_of_birth">Date of Birth</label>
                    <input type="date" class="form-control form-control-lg" id="editDateOfBirth">
                </div>
                <div class="col-md-6">
                    <label for="editNationality" class="form-label" data-i18n="nationality">Nationality</label>
                    <input type="text" class="form-control form-control-lg" id="editNationality" placeholder="e.g., USA, GBR, DEU">
                </div>
            </div>
            <div class="d-flex gap-2 mb-4">
                <button type="button" class="btn btn-outline-secondary" onclick="cancelEdit()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="me-1" viewBox="0 0 16 16">
                        <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
                    </svg>
                    <span data-i18n="cancel">Cancel</span>
                </button>
                <button type="button" class="btn btn-success" onclick="saveEdit()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="me-1" viewBox="0 0 16 16">
                        <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
                    </svg>
                    <span data-i18n="save_changes">Save Changes</span>
                </button>
            </div>
        </div>

        <form id="verifyForm" method="post" action="{% url 'kiosk:dw_registration_card' %}">
            {% csrf_token %}
            <input type="hidden" name="first_name" id="inputFirstName">
            <input type="hidden" name="last_name" id="inputLastName">
            <input type="hidden" name="passport_number" id="inputPassportNumber">
            <input type="hidden" name="date_of_birth" id="inputDateOfBirth">
            <input type="hidden" name="nationality" id="inputNationality">
            <input type="hidden" name="nationality_code" id="inputNationalityCode">
            <input type="hidden" name="issuer_code" id="inputIssuerCode">
            <input type="hidden" name="sex" id="inputSex">
            <input type="hidden" name="expiry_date" id="inputExpiryDate">
            <input type="hidden" name="document_session_id" id="inputDocumentSessionId">
            <!-- Access method is selected after document signing -->

            <div class="d-flex gap-2 flex-wrap" id="resultButtons">
                <button type="button" class="btn btn-outline-secondary btn-lg" onclick="resetScan()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-right: 8px;">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                    <span data-i18n="scan_again">Scan Again</span>
                </button>
                <button type="submit" class="btn btn-primary btn-lg">
                    <span data-i18n="continue">Continue</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16" style="margin-left: 8px;">
                        <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// =============================================================================
// Real-Time WebSocket Video Streaming (24fps with Zero HTTP Overhead)
// =============================================================================

// Configuration
const MRZ_SERVICE_URL = '{{ mrz_service_url|default:"/api/mrz" }}';
const DETECTION_FPS = 24;  // 24fps for smooth detection
const DETECTION_WIDTH = 1080;  // Full HD width for accurate detection
const DETECTION_QUALITY = 0.6;  // Balanced quality/size
const CAPTURE_QUALITY = 0.9;  // High quality for final capture
const USE_WEBP = true;  // Use WebP for better compression (if supported)
const USE_WEBSOCKET = true;  // Use WebSocket for real-time streaming (faster than HTTP)

// Stream Session State
let streamSessionId = null;
let stream = null;
let isProcessing = false;
let lastDetection = null;

// WebSocket connection
let ws = null;
let wsConnected = false;
let wsReconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 3;

// Detection loop state
let detectionInterval = null;
let pendingRequest = false;  // Non-blocking: skip if previous request pending
let frameCount = 0;  // Frame counter for FPS display

// Corner detection tracking
let cornerDetectionActive = false;

// Canvases
let detectionCanvas = null;  // Small canvas for detection frames

// DOM Elements
const video = document.getElementById('cameraVideo');
const captureCanvas = document.getElementById('captureCanvas');
const overlayCanvas = document.getElementById('overlayCanvas');
const detectionDot = document.getElementById('detectionDot');
const detectionText = document.getElementById('detectionText');
const passportGuide = document.getElementById('passportGuide');
const stabilityContainer = document.getElementById('stabilityContainer');
const stabilityBar = document.getElementById('stabilityBar');
const stabilityText = document.getElementById('stabilityText');
const qualityScoreEl = document.getElementById('qualityScore');
const qualityValueEl = document.getElementById('qualityValue');
const countdown = document.getElementById('captureCountdown');
const cameraError = document.getElementById('cameraError');
const processingOverlay = document.getElementById('processingOverlay');
const cameraSection = document.getElementById('cameraSection');
const resultsSection = document.getElementById('resultsSection');
const manualEntrySection = document.getElementById('manualEntrySection');
const captureBtn = document.getElementById('captureBtn');

// Initialize on page load
document.addEventListener('DOMContentLoaded', initCamera);

// =============================================================================
// Camera & Stream Session Management
// =============================================================================

async function initCamera() {
    cameraError.style.display = 'none';
    updateDetectionStatus('initializing', 'Starting camera...');
    
    try {
        // Get camera stream
        stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                facingMode: 'environment'
            }
        });
        
        video.srcObject = stream;
        
        video.onloadedmetadata = async () => {
            // Ensure video is playing
            try {
                await video.play();
                console.log('Video playing:', !video.paused);
            } catch (e) {
                console.warn('Video autoplay failed:', e);
            }
            
            // Setup capture canvas (full resolution)
            captureCanvas.width = video.videoWidth;
            captureCanvas.height = video.videoHeight;
            overlayCanvas.width = video.videoWidth;
            overlayCanvas.height = video.videoHeight;
            
            // Setup detection canvas (tiny for speed)
            detectionCanvas = document.createElement('canvas');
            const scale = DETECTION_WIDTH / video.videoWidth;
            detectionCanvas.width = DETECTION_WIDTH;
            detectionCanvas.height = Math.round(video.videoHeight * scale);
            
            console.log(`Detection: ${detectionCanvas.width}x${detectionCanvas.height}, Capture: ${video.videoWidth}x${video.videoHeight}`);
            
            // Create stream session on backend
            await createStreamSession();
            
            // Start detection loop
            startDetectionLoop();
        };
        
    } catch (error) {
        console.error('Camera error:', error);
        cameraError.style.display = 'block';
        updateDetectionStatus('error', 'Camera access denied');
    }
}

async function createStreamSession() {
    if (USE_WEBSOCKET) {
        return createWebSocketSession();
    }
    
    // Fallback to HTTP
    try {
        const response = await fetch(MRZ_SERVICE_URL + '/stream/session/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        const result = await response.json();
        
        if (result.session_id) {
            streamSessionId = result.session_id;
            console.log('Stream session created:', streamSessionId);
            updateDetectionStatus('searching', 'Searching for document...');
            captureBtn.disabled = false;
        } else {
            console.error('Failed to create stream session:', result);
            updateDetectionStatus('error', 'Service unavailable');
        }
    } catch (error) {
        console.error('Stream session error:', error);
        updateDetectionStatus('error', 'Connection error');
    }
}

function createWebSocketSession() {
    return new Promise((resolve, reject) => {
        // Build WebSocket URL from MRZ service URL
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}${MRZ_SERVICE_URL}/stream/ws/`;
        
        console.log('Connecting to WebSocket:', wsUrl);
        
        try {
            ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                wsConnected = true;
                wsReconnectAttempts = 0;
                
                // Initialize session
                ws.send(JSON.stringify({ action: 'init' }));
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.action === 'init_ok') {
                        streamSessionId = data.session_id;
                        console.log('WebSocket session ready:', streamSessionId);
                        updateDetectionStatus('searching', 'Searching for document...');
                        captureBtn.disabled = false;
                        resolve();
                    } else if (data.action === 'capture_result') {
                        handleCaptureResult(data);
                    } else if (data.detected !== undefined) {
                        // Detection result
                        pendingRequest = false;
                        handleDetectionResult(data);
                    } else if (data.error) {
                        console.warn('WebSocket error:', data.error);
                        pendingRequest = false;
                    }
                } catch (e) {
                    console.error('WebSocket message parse error:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                wsConnected = false;
            };
            
            ws.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                wsConnected = false;
                ws = null;
                
                // Auto-reconnect if unexpected close
                if (detectionLoopRunning && wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    wsReconnectAttempts++;
                    console.log(`Reconnecting... (attempt ${wsReconnectAttempts})`);
                    setTimeout(() => createWebSocketSession(), 1000);
                }
            };
            
            // Timeout for connection
            setTimeout(() => {
                if (!wsConnected) {
                    console.warn('WebSocket connection timeout, falling back to HTTP');
                    ws?.close();
                    reject(new Error('Connection timeout'));
                }
            }, 5000);
            
        } catch (error) {
            console.error('WebSocket creation error:', error);
            reject(error);
        }
    });
}

async function closeStreamSession() {
    if (ws && wsConnected) {
        try {
            ws.send(JSON.stringify({ action: 'close' }));
            ws.close();
        } catch (e) {}
        ws = null;
        wsConnected = false;
    }
    
    if (streamSessionId) {
        try {
            await fetch(MRZ_SERVICE_URL + `/stream/session/${streamSessionId}/`, {
                method: 'DELETE'
            });
            console.log('Stream session closed:', streamSessionId);
        } catch (e) {
            // Ignore errors on cleanup
        }
        streamSessionId = null;
    }
}

// =============================================================================
// Detection Loop (Video Frame Callback - Native FPS)
// =============================================================================

let detectionLoopRunning = false;
let targetFrameInterval = 1000 / DETECTION_FPS;  // ms between frames to process
let lastFrameTime = 0;

function startDetectionLoop() {
    if (detectionLoopRunning || !stream || !streamSessionId) return;
    detectionLoopRunning = true;
    pendingRequest = false;
    lastFrameTime = 0;
    
    console.log(`Detection loop started at ${DETECTION_FPS}fps`);
    
    // Use setInterval for reliable frame sending across all browsers
    detectionInterval = setInterval(() => {
        if (!detectionLoopRunning || isProcessing || pendingRequest) return;
        sendDetectionFrame();
    }, targetFrameInterval);
    
    // FPS counter update
    setInterval(() => {
        document.getElementById('fpsCounter').textContent = frameCount + ' fps';
        frameCount = 0;
    }, 1000);
}

function scheduleVideoFrame() {
    if (!detectionLoopRunning) {
        console.log('scheduleVideoFrame: Not running, returning');
        return;
    }
    
    video.requestVideoFrameCallback((now, metadata) => {
        if (!detectionLoopRunning || isProcessing) {
            scheduleVideoFrame();
            return;
        }
        
        // Throttle to target FPS
        if (now - lastFrameTime >= targetFrameInterval) {
            lastFrameTime = now;
            
            // Only send if not waiting for previous response
            if (!pendingRequest) {
                console.log('scheduleVideoFrame: Sending frame');
                sendDetectionFrame();
            }
        }
        
        // Schedule next frame
        scheduleVideoFrame();
    });
}

// Check WebP support (cached result)
let webpSupported = null;
async function checkWebPSupport() {
    if (webpSupported !== null) return webpSupported;
    const testCanvas = document.createElement('canvas');
    testCanvas.width = 1;
    testCanvas.height = 1;
    webpSupported = testCanvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    console.log('WebP support:', webpSupported);
    return webpSupported;
}

async function sendDetectionFrame() {
    if (!streamSessionId || !detectionCanvas) return;
    
    // Draw to canvas (efficient - browser optimizes this)
    const ctx = detectionCanvas.getContext('2d');
    ctx.drawImage(video, 0, 0, detectionCanvas.width, detectionCanvas.height);
    
    // Use WebP if supported (30% smaller), fallback to JPEG
    const useWebP = USE_WEBP && await checkWebPSupport();
    const mimeType = useWebP ? 'image/webp' : 'image/jpeg';
    
    // Get compressed blob
    const blob = await new Promise(resolve => {
        detectionCanvas.toBlob(resolve, mimeType, DETECTION_QUALITY);
    });
    
    pendingRequest = true;
    frameCount++;
    
    // Use WebSocket for real-time streaming (no HTTP overhead)
    if (USE_WEBSOCKET && ws && wsConnected) {
        try {
            // Send binary frame directly (most efficient)
            const buffer = await blob.arrayBuffer();
            ws.send(buffer);
            return;
        } catch (e) {
            console.warn('WebSocket send failed:', e);
            // Fall through to HTTP
        }
    }
    
    // Fallback to HTTP with compression
    const frameData = await blobToBase64(blob);
    
    // Build payload with format hint
    const payload = JSON.stringify({
        session_id: streamSessionId,
        image: frameData,
        format: useWebP ? 'webp' : 'jpeg'
    });
    
    // Compress with gzip if available (additional ~60% compression)
    let body = payload;
    let headers = { 'Content-Type': 'application/json' };
    
    if (typeof CompressionStream !== 'undefined') {
        try {
            const encoder = new TextEncoder();
            const compressed = await compressGzip(encoder.encode(payload));
            body = compressed;
            headers = { 'Content-Type': 'application/json', 'Content-Encoding': 'gzip' };
        } catch (e) {
            // Fallback to uncompressed
        }
    }
    
    fetch(MRZ_SERVICE_URL + '/stream/frame/', {
        method: 'POST',
        headers: headers,
        body: body
    })
    .then(response => response.json())
    .then(result => {
        pendingRequest = false;
        handleDetectionResult(result);
    })
    .catch(error => {
        pendingRequest = false;
        console.warn('Detection error:', error.message);
    });
}

function blobToBase64(blob) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            const base64 = reader.result.split(',')[1];
            resolve(base64);
        };
        reader.readAsDataURL(blob);
    });
}

async function compressGzip(data) {
    const stream = new Blob([data]).stream();
    const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));
    return await new Response(compressedStream).blob();
}

function stopDetectionLoop() {
    detectionLoopRunning = false;
    
    if (detectionInterval) {
        clearInterval(detectionInterval);
        detectionInterval = null;
    }
    
    console.log('Detection stopped');
}

function handleDetectionResult(result) {
    lastDetection = result;
    
    // Clear overlay
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
    if (result.error) {
        // Keep searching on error
        updateDetectionStatus('searching', 'Searching for document...');
        hideStabilityUI();
        return;
    }
    
    if (result.detected && result.corners) {
        // Document detected - draw corners
        drawDetectionOverlay(result.corners, result.confidence || 0);
        
        // Show stability progress
        const stableCount = result.stable_count || 0;
        const stableRequired = result.stable_required || 8;
        const progress = Math.min((stableCount / stableRequired) * 100, 100);
        
        showStabilityUI(progress, stableCount, stableRequired);
        
        // Show quality if available
        if (result.quality_score) {
            showQuality(result.quality_score);
        }
        
        // Update status based on stability
        if (result.ready_for_capture) {
            updateDetectionStatus('ready', 'Ready! Capturing automatically...');
            passportGuide.classList.add('ready');
            
            // Auto-capture when MRZ backend signals ready
            if (!isProcessing) {
                performCapture();
            }
        } else if (stableCount > 0) {
            updateDetectionStatus('stabilizing', `Hold steady... (${stableCount}/${stableRequired})`);
            passportGuide.classList.add('detected');
            passportGuide.classList.remove('ready');
        } else {
            updateDetectionStatus('detected', 'Document detected - hold steady');
            passportGuide.classList.add('detected');
            passportGuide.classList.remove('ready');
        }
    } else {
        // No document detected
        updateDetectionStatus('searching', 'Searching for document...');
        passportGuide.classList.remove('detected', 'ready');
        hideStabilityUI();
        hideQuality();
    }
}

// =============================================================================
// Overlay Drawing
// =============================================================================

function drawDetectionOverlay(corners, confidence) {
    const ctx = overlayCanvas.getContext('2d');
    
    if (!corners || corners.length !== 4) return;
    
    // Scale corners from detection frame (320px) to overlay canvas
    // Detection was done on tiny frame, so scale up to video size
    const detectionScale = video.videoWidth / DETECTION_WIDTH;
    const overlayScaleX = overlayCanvas.width / video.videoWidth;
    const overlayScaleY = overlayCanvas.height / video.videoHeight;
    
    const scaledCorners = corners.map(([x, y]) => [
        x * detectionScale * overlayScaleX,
        y * detectionScale * overlayScaleY
    ]);
    
    // Draw filled polygon with transparency
    ctx.beginPath();
    ctx.moveTo(scaledCorners[0][0], scaledCorners[0][1]);
    for (let i = 1; i < 4; i++) {
        ctx.lineTo(scaledCorners[i][0], scaledCorners[i][1]);
    }
    ctx.closePath();
    
    // Fill with semi-transparent green
    ctx.fillStyle = `rgba(34, 197, 94, ${0.1 + confidence * 0.15})`;
    ctx.fill();
    
    // Draw border
    ctx.strokeStyle = confidence > 0.7 ? '#22c55e' : '#f59e0b';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Draw corner circles
    ctx.fillStyle = confidence > 0.7 ? '#22c55e' : '#f59e0b';
    for (const [x, y] of scaledCorners) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}

// =============================================================================
// UI Updates
// =============================================================================

function updateDetectionStatus(state, text) {
    detectionText.textContent = text;
    
    // Update dot color based on state
    detectionDot.classList.remove('searching', 'detected', 'ready', 'error', 'capturing');
    detectionDot.classList.add(state);
    
    // Also update dot detected class for CSS
    if (state === 'detected' || state === 'stabilizing' || state === 'ready') {
        detectionDot.classList.add('detected');
    }
}

function showStabilityUI(progress, current, required) {
    stabilityContainer.style.display = 'flex';
    stabilityBar.style.width = `${progress}%`;
    
    if (progress >= 100) {
        stabilityBar.classList.add('complete');
        stabilityText.textContent = 'Ready to capture!';
    } else {
        stabilityBar.classList.remove('complete');
        stabilityText.textContent = `Hold steady... ${current}/${required}`;
    }
}

function hideStabilityUI() {
    stabilityContainer.style.display = 'none';
    stabilityBar.style.width = '0%';
    stabilityBar.classList.remove('complete');
}

function showQuality(score) {
    qualityScoreEl.style.display = 'block';
    qualityValueEl.textContent = Math.round(score);
    
    // Color based on quality
    if (score >= 60) {
        qualityValueEl.style.color = '#22c55e';
    } else if (score >= 40) {
        qualityValueEl.style.color = '#f59e0b';
    } else {
        qualityValueEl.style.color = '#ef4444';
    }
}

function hideQuality() {
    qualityScoreEl.style.display = 'none';
}

// =============================================================================
// Capture
// =============================================================================

// WebSocket capture result handler
function handleCaptureResult(result) {
    processingOverlay.style.display = 'none';
    
    if (result.success && result.data) {
        showResults(result.data);
    } else {
        console.log('WebSocket capture failed, trying direct extraction...');
        fallbackExtraction();
    }
}

async function performCapture() {
    if (isProcessing || !streamSessionId) return;
    
    isProcessing = true;
    captureBtn.disabled = true;
    stopDetectionLoop();
    
    // Show capture feedback
    updateDetectionStatus('capturing', 'Capturing...');
    countdown.style.display = 'block';
    countdown.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 8.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4H2z"/></svg>';
    
    setTimeout(async () => {
        countdown.style.display = 'none';
        processingOverlay.style.display = 'flex';
        
        try {
            // Use WebSocket for capture if available
            if (USE_WEBSOCKET && ws && wsConnected) {
                ws.send(JSON.stringify({ action: 'capture' }));
                // Result will be handled by handleCaptureResult via WebSocket message
                return;
            }
            
            // Fallback to HTTP
            const payload = JSON.stringify({ session_id: streamSessionId });
            let body = payload;
            let headers = { 'Content-Type': 'application/json' };
            
            if (typeof CompressionStream !== 'undefined') {
                try {
                    const compressed = await compressGzip(new TextEncoder().encode(payload));
                    body = compressed;
                    headers = { 'Content-Type': 'application/json', 'Content-Encoding': 'gzip' };
                } catch (e) {}
            }
            
            const response = await fetch(MRZ_SERVICE_URL + '/stream/capture/', {
                method: 'POST',
                headers: headers,
                body: body
            });
            
            const result = await response.json();
            
            if (result.success && result.data) {
                showResults(result.data);
            } else {
                // Fallback: try one-shot extraction with current frame
                console.log('Stream capture failed, trying direct extraction...');
                await fallbackExtraction();
            }
            
        } catch (error) {
            console.error('Capture error:', error);
            showError('Connection error. Please try again or enter manually.');
            resetForRetry();
        }
    }, 300);
}

async function fallbackExtraction() {
    // Capture high-quality frame directly
    const ctx = captureCanvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    
    // Use WebP if supported for better compression
    const useWebP = USE_WEBP && await checkWebPSupport();
    const mimeType = useWebP ? 'image/webp' : 'image/jpeg';
    const extension = useWebP ? 'webp' : 'jpg';
    
    // Get compressed blob
    const blob = await new Promise(resolve => {
        captureCanvas.toBlob(resolve, mimeType, CAPTURE_QUALITY);
    });
    const imageData = await blobToBase64(blob);
    
    try {
        // Compress the payload for cloud server
        const payload = JSON.stringify({
            image: imageData,
            filename: `passport_scan.${extension}`,
            format: useWebP ? 'webp' : 'jpeg'
        });
        
        let body = payload;
        let headers = { 'Content-Type': 'application/json' };
        
        if (typeof CompressionStream !== 'undefined') {
            try {
                const compressed = await compressGzip(new TextEncoder().encode(payload));
                body = compressed;
                headers = { 'Content-Type': 'application/json', 'Content-Encoding': 'gzip' };
                console.log(`Compressed: ${payload.length} -> ${compressed.size} bytes`);
            } catch (e) {}
        }
        
        const response = await fetch(MRZ_SERVICE_URL + '/extract/', {
            method: 'POST',
            headers: headers,
            body: body
        });
        
        const result = await response.json();
        
        if (result.success && result.data) {
            showResults(result.data);
        } else {
            showError(result.error || 'Failed to extract passport data. Try again or enter manually.');
            resetForRetry();
        }
    } catch (error) {
        showError('Connection error. Please try again or enter manually.');
        resetForRetry();
    }
}

// =============================================================================
// Results Display
// =============================================================================

function showResults(data) {
    processingOverlay.style.display = 'none';
    stopCamera();
    
    // Populate form fields
    document.getElementById('inputFirstName').value = data.given_name || '';
    document.getElementById('inputLastName').value = data.surname || '';
    document.getElementById('inputPassportNumber').value = data.document_number || '';
    document.getElementById('inputDateOfBirth').value = formatDate(data.birth_date);
    document.getElementById('inputNationality').value = data.nationality_code || '';
    document.getElementById('inputNationalityCode').value = data.nationality_code || '';
    document.getElementById('inputIssuerCode').value = data.issuer_code || '';
    document.getElementById('inputSex').value = data.sex || '';
    document.getElementById('inputExpiryDate').value = data.expiry_date || '';
    document.getElementById('inputDocumentSessionId').value = streamSessionId || '';
    
    // Build data display
    const grid = document.getElementById('passportDataGrid');
    grid.innerHTML = `
        <div class="data-field">
            <div class="label" data-i18n="surname">Surname</div>
            <div class="value">${data.surname || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="given_names">Given Names</div>
            <div class="value">${data.given_name || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="passport_number">Passport Number</div>
            <div class="value">${data.document_number || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="nationality">Nationality</div>
            <div class="value">${data.nationality_code || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="date_of_birth">Date of Birth</div>
            <div class="value">${formatDate(data.birth_date) || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="sex">Sex</div>
            <div class="value">${data.sex || '-'}</div>
        </div>
    `;
    
    // Show results section
    cameraSection.style.display = 'none';
    resultsSection.classList.add('visible');
}

function formatDate(dateStr) {
    if (!dateStr) return '';
    // Handle YYMMDD format
    if (dateStr.length === 6) {
        const year = parseInt(dateStr.substring(0, 2));
        const month = dateStr.substring(2, 4);
        const day = dateStr.substring(4, 6);
        const century = year > 30 ? '19' : '20';
        return `${century}${year}-${month}-${day}`;
    }
    return dateStr;
}

function showError(message) {
    alert(message);
}

function resetForRetry() {
    isProcessing = false;
    processingOverlay.style.display = 'none';
    countdown.style.display = 'none';
    captureBtn.disabled = false;
    
    // Clear overlay
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
    // Restart detection if we have a session
    if (streamSessionId) {
        startDetectionLoop();
        updateDetectionStatus('searching', 'Searching for document...');
    }
}

function resetScan() {
    resultsSection.classList.remove('visible');
    cameraSection.style.display = 'block';
    isProcessing = false;
    captureBtn.disabled = false;
    
    // Re-initialize camera and stream session
    initCamera();
}

// =============================================================================
// Manual Entry
// =============================================================================

function showManualEntry() {
    stopCamera();
    cameraSection.style.display = 'none';
    resultsSection.classList.remove('visible');
    manualEntrySection.style.display = 'block';
}

function hideManualEntry() {
    manualEntrySection.style.display = 'none';
    cameraSection.style.display = 'block';
    initCamera();
}

// =============================================================================
// Cleanup
// =============================================================================

function stopCamera() {
    stopDetectionLoop();
    closeStreamSession();
    
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
    }
}

// =============================================================================
// Edit Mode Functions
// =============================================================================

function enterEditMode() {
    document.getElementById('editFirstName').value = document.getElementById('inputFirstName').value;
    document.getElementById('editLastName').value = document.getElementById('inputLastName').value;
    document.getElementById('editPassportNumber').value = document.getElementById('inputPassportNumber').value;
    document.getElementById('editDateOfBirth').value = document.getElementById('inputDateOfBirth').value;
    document.getElementById('editNationality').value = document.getElementById('inputNationality').value;
    
    document.getElementById('displayMode').style.display = 'none';
    document.getElementById('editMode').style.display = 'block';
    document.getElementById('resultButtons').style.display = 'none';
}

function cancelEdit() {
    document.getElementById('displayMode').style.display = 'block';
    document.getElementById('editMode').style.display = 'none';
    document.getElementById('resultButtons').style.display = 'flex';
}

function saveEdit() {
    const firstName = document.getElementById('editFirstName').value.trim();
    const lastName = document.getElementById('editLastName').value.trim();
    const passportNumber = document.getElementById('editPassportNumber').value.trim();
    const dateOfBirth = document.getElementById('editDateOfBirth').value;
    const nationality = document.getElementById('editNationality').value.trim();
    
    if (!firstName || !lastName) {
        alert('First Name and Last Name are required.');
        return;
    }
    
    document.getElementById('inputFirstName').value = firstName;
    document.getElementById('inputLastName').value = lastName;
    document.getElementById('inputPassportNumber').value = passportNumber;
    document.getElementById('inputDateOfBirth').value = dateOfBirth;
    document.getElementById('inputNationality').value = nationality;
    
    const grid = document.getElementById('passportDataGrid');
    grid.innerHTML = `
        <div class="data-field">
            <div class="label" data-i18n="surname">Surname</div>
            <div class="value">${lastName || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="given_names">Given Names</div>
            <div class="value">${firstName || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="passport_number">Passport Number</div>
            <div class="value">${passportNumber || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="nationality">Nationality</div>
            <div class="value">${nationality || '-'}</div>
        </div>
        <div class="data-field">
            <div class="label" data-i18n="date_of_birth">Date of Birth</div>
            <div class="value">${dateOfBirth || '-'}</div>
        </div>
    `;
    
    document.getElementById('displayMode').style.display = 'block';
    document.getElementById('editMode').style.display = 'none';
    document.getElementById('resultButtons').style.display = 'flex';
}

// =============================================================================
// Access Method Toggle
// =============================================================================

function toggleVerifyAccess(btn, inputId) {
    var isPressed = btn.getAttribute('aria-pressed') === 'true';
    var newState = !isPressed;
    
    btn.setAttribute('aria-pressed', String(newState));
    document.getElementById(inputId).value = newState ? '1' : '';
}

// =============================================================================
// Form Validation
// =============================================================================

document.getElementById('verifyForm').onsubmit = function(e) {
    var keycard = document.getElementById('verify_access_keycard').value;
    var face = document.getElementById('verify_access_face').value;
    if (!keycard && !face) {
        e.preventDefault();
        alert('Please choose at least one access method.');
        return false;
    }
    var submitBtn = this.querySelector('button[type="submit"]');
    if (submitBtn) {
        setTimeout(function() {
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Processing...';
        }, 0);
    }
    return true;
};

document.getElementById('manualEntryForm').onsubmit = function(e) {
    var keycard = document.getElementById('manual_access_keycard').value;
    var face = document.getElementById('manual_access_face').value;
    if (!keycard && !face) {
        e.preventDefault();
        alert('Please choose at least one access method.');
        return false;
    }
    var submitBtn = this.querySelector('button[type="submit"]');
    if (submitBtn) {
        setTimeout(function() {
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Processing...';
        }, 0);
    }
    return true;
};

// Cleanup on page unload
window.addEventListener('beforeunload', stopCamera);
</script>
{% endblock %}
